// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// User user
//
// swagger:model User
type User struct {

	// credit score data
	CreditScoreData *CreditScoreData `json:"credit_score_data,omitempty"`

	// date of birth
	// Format: date
	DateOfBirth strfmt.Date `json:"date_of_birth,omitempty"`

	// Cannot already be in use for an existing account.
	// Required: true
	// Max Length: 512
	// Format: email
	Email *strfmt.Email `json:"email"`

	// family name
	// Required: true
	// Max Length: 255
	FamilyName *string `json:"family_name"`

	// given name
	// Required: true
	// Max Length: 255
	GivenName *string `json:"given_name"`

	// landline
	// Max Length: 64
	Landline string `json:"landline,omitempty"`

	// mobile
	// Max Length: 64
	Mobile string `json:"mobile,omitempty"`

	// opted in for marketing
	// Required: true
	OptedInForMarketing *bool `json:"opted_in_for_marketing"`

	// opted in to third parties
	OptedInToThirdParties *bool `json:"opted_in_to_third_parties,omitempty"`

	// Priority Services Register details for the user
	Psr struct {
		PSR
	} `json:"psr,omitempty"`

	// title
	// Max Length: 255
	Title string `json:"title,omitempty"`
}

// Validate validates this user
func (m *User) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreditScoreData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFamilyName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGivenName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLandline(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptedInForMarketing(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePsr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *User) validateCreditScoreData(formats strfmt.Registry) error {
	if swag.IsZero(m.CreditScoreData) { // not required
		return nil
	}

	if m.CreditScoreData != nil {
		if err := m.CreditScoreData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credit_score_data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credit_score_data")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(m.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("date_of_birth", "body", "date", m.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *User) validateEmail(formats strfmt.Registry) error {

	if err := validate.Required("email", "body", m.Email); err != nil {
		return err
	}

	if err := validate.MaxLength("email", "body", m.Email.String(), 512); err != nil {
		return err
	}

	if err := validate.FormatOf("email", "body", "email", m.Email.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *User) validateFamilyName(formats strfmt.Registry) error {

	if err := validate.Required("family_name", "body", m.FamilyName); err != nil {
		return err
	}

	if err := validate.MaxLength("family_name", "body", *m.FamilyName, 255); err != nil {
		return err
	}

	return nil
}

func (m *User) validateGivenName(formats strfmt.Registry) error {

	if err := validate.Required("given_name", "body", m.GivenName); err != nil {
		return err
	}

	if err := validate.MaxLength("given_name", "body", *m.GivenName, 255); err != nil {
		return err
	}

	return nil
}

func (m *User) validateLandline(formats strfmt.Registry) error {
	if swag.IsZero(m.Landline) { // not required
		return nil
	}

	if err := validate.MaxLength("landline", "body", m.Landline, 64); err != nil {
		return err
	}

	return nil
}

func (m *User) validateMobile(formats strfmt.Registry) error {
	if swag.IsZero(m.Mobile) { // not required
		return nil
	}

	if err := validate.MaxLength("mobile", "body", m.Mobile, 64); err != nil {
		return err
	}

	return nil
}

func (m *User) validateOptedInForMarketing(formats strfmt.Registry) error {

	if err := validate.Required("opted_in_for_marketing", "body", m.OptedInForMarketing); err != nil {
		return err
	}

	return nil
}

func (m *User) validatePsr(formats strfmt.Registry) error {
	if swag.IsZero(m.Psr) { // not required
		return nil
	}

	return nil
}

func (m *User) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(m.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("title", "body", m.Title, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this user based on the context it is used
func (m *User) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreditScoreData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePsr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *User) contextValidateCreditScoreData(ctx context.Context, formats strfmt.Registry) error {

	if m.CreditScoreData != nil {

		if swag.IsZero(m.CreditScoreData) { // not required
			return nil
		}

		if err := m.CreditScoreData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credit_score_data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credit_score_data")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidatePsr(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

// MarshalBinary interface implementation
func (m *User) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *User) UnmarshalBinary(b []byte) error {
	var res User
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
