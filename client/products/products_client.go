// Code generated by go-swagger; DO NOT EDIT.

package products

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new products API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new products API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new products API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for products API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ListElectricityTariffDayUnitRates(params *ListElectricityTariffDayUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffDayUnitRatesOK, error)

	ListElectricityTariffNightUnitRates(params *ListElectricityTariffNightUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffNightUnitRatesOK, error)

	ListElectricityTariffStandardUnitRates(params *ListElectricityTariffStandardUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffStandardUnitRatesOK, error)

	ListElectricityTariffStandingCharges(params *ListElectricityTariffStandingChargesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffStandingChargesOK, error)

	ListGasTariffStandardUnitRates(params *ListGasTariffStandardUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListGasTariffStandardUnitRatesOK, error)

	ListGasTariffStandingCharges(params *ListGasTariffStandingChargesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListGasTariffStandingChargesOK, error)

	ListProducts(params *ListProductsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProductsOK, error)

	RetrieveaProduct(params *RetrieveaProductParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveAProductOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	ListElectricityTariffDayUnitRates Abstract base class for generic types.

On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::

	class Mapping[KT, VT]:
	    def __getitem__(self, key: KT) -> VT:
	        ...
	    # Etc.

On older versions of Python, however, generic classes have to
explicitly inherit from Generic.

After a class has been declared to be generic, it can then be used as
follows::

	def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	    try:
	        return mapping[key]
	    except KeyError:
	        return default
*/
func (a *Client) ListElectricityTariffDayUnitRates(params *ListElectricityTariffDayUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffDayUnitRatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListElectricityTariffDayUnitRatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Electricity Tariff Day Unit Rates",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/electricity-tariffs/{tariff_code}/day-unit-rates/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListElectricityTariffDayUnitRatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListElectricityTariffDayUnitRatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Electricity Tariff Day Unit Rates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ListElectricityTariffNightUnitRates Abstract base class for generic types.

On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::

	class Mapping[KT, VT]:
	    def __getitem__(self, key: KT) -> VT:
	        ...
	    # Etc.

On older versions of Python, however, generic classes have to
explicitly inherit from Generic.

After a class has been declared to be generic, it can then be used as
follows::

	def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	    try:
	        return mapping[key]
	    except KeyError:
	        return default
*/
func (a *Client) ListElectricityTariffNightUnitRates(params *ListElectricityTariffNightUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffNightUnitRatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListElectricityTariffNightUnitRatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Electricity Tariff Night Unit Rates",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/electricity-tariffs/{tariff_code}/night-unit-rates/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListElectricityTariffNightUnitRatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListElectricityTariffNightUnitRatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Electricity Tariff Night Unit Rates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ListElectricityTariffStandardUnitRates Abstract base class for generic types.

On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::

	class Mapping[KT, VT]:
	    def __getitem__(self, key: KT) -> VT:
	        ...
	    # Etc.

On older versions of Python, however, generic classes have to
explicitly inherit from Generic.

After a class has been declared to be generic, it can then be used as
follows::

	def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	    try:
	        return mapping[key]
	    except KeyError:
	        return default
*/
func (a *Client) ListElectricityTariffStandardUnitRates(params *ListElectricityTariffStandardUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffStandardUnitRatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListElectricityTariffStandardUnitRatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Electricity Tariff Standard Unit Rates",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/electricity-tariffs/{tariff_code}/standard-unit-rates/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListElectricityTariffStandardUnitRatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListElectricityTariffStandardUnitRatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Electricity Tariff Standard Unit Rates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ListElectricityTariffStandingCharges Abstract base class for generic types.

On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::

	class Mapping[KT, VT]:
	    def __getitem__(self, key: KT) -> VT:
	        ...
	    # Etc.

On older versions of Python, however, generic classes have to
explicitly inherit from Generic.

After a class has been declared to be generic, it can then be used as
follows::

	def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	    try:
	        return mapping[key]
	    except KeyError:
	        return default
*/
func (a *Client) ListElectricityTariffStandingCharges(params *ListElectricityTariffStandingChargesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListElectricityTariffStandingChargesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListElectricityTariffStandingChargesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Electricity Tariff Standing Charges",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/electricity-tariffs/{tariff_code}/standing-charges/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListElectricityTariffStandingChargesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListElectricityTariffStandingChargesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Electricity Tariff Standing Charges: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ListGasTariffStandardUnitRates Abstract base class for generic types.

On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::

	class Mapping[KT, VT]:
	    def __getitem__(self, key: KT) -> VT:
	        ...
	    # Etc.

On older versions of Python, however, generic classes have to
explicitly inherit from Generic.

After a class has been declared to be generic, it can then be used as
follows::

	def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	    try:
	        return mapping[key]
	    except KeyError:
	        return default
*/
func (a *Client) ListGasTariffStandardUnitRates(params *ListGasTariffStandardUnitRatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListGasTariffStandardUnitRatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListGasTariffStandardUnitRatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Gas Tariff Standard Unit Rates",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/gas-tariffs/{tariff_code}/standard-unit-rates/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListGasTariffStandardUnitRatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListGasTariffStandardUnitRatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Gas Tariff Standard Unit Rates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	ListGasTariffStandingCharges Abstract base class for generic types.

On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::

	class Mapping[KT, VT]:
	    def __getitem__(self, key: KT) -> VT:
	        ...
	    # Etc.

On older versions of Python, however, generic classes have to
explicitly inherit from Generic.

After a class has been declared to be generic, it can then be used as
follows::

	def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
	    try:
	        return mapping[key]
	    except KeyError:
	        return default
*/
func (a *Client) ListGasTariffStandingCharges(params *ListGasTariffStandingChargesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListGasTariffStandingChargesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListGasTariffStandingChargesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Gas Tariff Standing Charges",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/gas-tariffs/{tariff_code}/standing-charges/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListGasTariffStandingChargesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListGasTariffStandingChargesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Gas Tariff Standing Charges: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListProducts Return a list of energy products. By default, results will be public energy products but if the authenticated organisations will also see products available to their organisation.
*/
func (a *Client) ListProducts(params *ListProductsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProductsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListProductsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "List Products",
		Method:             "GET",
		PathPattern:        "/v1/products/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListProductsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListProductsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for List Products: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RetrieveaProduct Retrieve the details of a product (including all its tariffs) for a particular point in time.
*/
func (a *Client) RetrieveaProduct(params *RetrieveaProductParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RetrieveAProductOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRetrieveaProductParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Retrieve a Product",
		Method:             "GET",
		PathPattern:        "/v1/products/{product_code}/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RetrieveaProductReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RetrieveAProductOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Retrieve a Product: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
